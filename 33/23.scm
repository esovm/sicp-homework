; Exercise 3.23.  A deque (``double-ended queue'') is a sequence in which items can be inserted and deleted at either the front or the rear. Operations on deques are the constructor make-deque, the predicate empty-deque?, selectors front-deque and rear-deque, and mutators front-insert-deque!, rear-insert-deque!, front-delete-deque!, and rear-delete-deque!. Show how to represent deques using pairs, and give implementations of the operations. All operations should be accomplished in O(1) steps.

; To implement deque, we should use double-linked list. Let's implement it with the following structure:
;  +-------------+
;  |             |
; [|][-]->[|][/] |
;  |       |     |
; [|][/]  [|][-]-+
;  a       b

(load "ch33_common.scm")

(define (make-deque)
  (let ((front-ptr nil)
        (rear-ptr nil))
    (define (empty-deque?)
      (null? front-ptr))
    (define (front-deque)
      (if (empty-deque?)
	  (error "FRONT called with an empty deque")
	  (caar front-ptr)))
    (define (rear-deque)
      (if (empty-deque?)
	  (error "REAR called with an empty deque")
	  (caar rear-ptr)))
    (define (front-insert-deque! item)
      (let ((new-subpair (cons item nil)))
	(let ((new-pair (cons new-subpair front-ptr)))
	  (if (empty-deque?)
	      (set! rear-ptr new-pair)
	      (set-cdr! (car front-ptr) new-pair))
	  (set! front-ptr new-pair)
	  #t)))
    (define (rear-insert-deque! item)
      (let ((new-subpair (cons item rear-ptr)))
	(let ((new-pair (cons new-subpair nil)))
	  (if (empty-deque?)
	      (set! front-ptr new-pair)
	      (set-cdr! rear-ptr new-pair))
	  (set! rear-ptr new-pair)
	  #t)))
    (define (front-delete-deque!)
      (if (empty-deque?)
	  (error "FRONT-DELETE! called with an empty deque")
	  (begin (set! front-ptr (cdr front-ptr))
		 (if (null? front-ptr)
		     (set! rear-ptr nil)
		     (set-cdr! (car front-ptr) nil))
		 #t)))
    (define (rear-delete-deque!)
      (if (empty-deque?)
	  (error "REAR-DELETE! called with an empty deque")
	  (begin (set! rear-ptr (cdar rear-ptr))
		 (if (null? rear-ptr)
		     (set! front-ptr nil)
		     (set-cdr! rear-ptr nil))
		 #t)))
    (define (dispatch m)
      (cond ((eq? m 'empty-deque?) (empty-deque?))
	    ((eq? m 'front-deque) (front-deque))
	    ((eq? m 'rear-deque) (rear-deque))
	    ((eq? m 'front-insert-deque!) front-insert-deque!)
	    ((eq? m 'rear-insert-deque!) rear-insert-deque!)
	    ((eq? m 'front-delete-deque!) (front-delete-deque!))
	    ((eq? m 'rear-delete-deque!) (rear-delete-deque!))
	    (else (error "Undefined operation -- MAKE-DEQUE" m))))
    dispatch))

(define (empty-deque? deque)
  (deque 'empty-deque?))
(define (front-deque deque)
  (deque 'front-deque))
(define (rear-deque deque)
  (deque 'rear-deque))
(define (front-insert-deque! deque item)
  ((deque 'front-insert-deque!) item))
(define (rear-insert-deque! deque item)
  ((deque 'rear-insert-deque!) item))
(define (front-delete-deque! deque)
  (deque 'front-delete-deque!))
(define (rear-delete-deque! deque)
  (deque 'rear-delete-deque!))

(define q1 (make-deque))
(assert (empty-deque? q1) #t)
(assert (front-insert-deque! q1 'a) #t)
(assert (rear-insert-deque! q1 'b) #t)
(assert (empty-deque? q1) #f)
(assert (front-deque q1) 'a)
(assert (rear-deque q1) 'b)
(assert (front-delete-deque! q1) #t)
(assert (front-deque q1) 'b)
(assert (rear-deque q1) 'b)
(assert (rear-delete-deque! q1) #t)
(assert (empty-deque? q1) #t)
(assert (rear-insert-deque! q1 'c) #t)
(assert (front-deque q1) 'c)
(assert (rear-deque q1) 'c)
(assert (empty-deque? q1) #f)
(assert (front-delete-deque! q1) #t)
(assert (empty-deque? q1) #t)
